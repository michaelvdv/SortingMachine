interface PP2IF
{
	in void startUp();
	in void startStop();
	in void abort();
	
	out void error00();		//Pusher Disconnected
	out void error01();		//Disc stuck at tube
	out void error02();		//LED01 Broken
	out void error03();		//Photocell 1 malfunction
	out void error04();		//Conveyor Belt Disconnected
	out void error05();		//Disc stuck in front of Photocell 1
	out void error06();		//Bucket Mechanism Malfunction
	out void pause();		
	out void unpause();
	out void aborted();
	out void finished();
	
	behaviour
	{
		enum State {Off, Idle, ToIdle, Push, Scan, MoveWhite, MoveBlack, Aborted};
		State state = State.Off;
		
		[state.ToIdle]{
			on optional:		state = State.Idle;
		}
		
		[state.Idle]{
			on optional:		state = State.Scan;
			on optional:		state = State.Push;
		}
		
		[State.Push]{
			on optional: 		state = State.Idle;
			on optional: 		state = State.Scan;
		}
		
		[State.Scan]{
			on optional:		state = State.MoveWhite;
			on optional:		state = State.MoveBlack;
		}
		
		[state.MoveWhite]{
			on optional:		state = State.Idle;
		}
		
		[state.MoveBlack]{
			on optional:		state = State.Idle;
		}		
		
		on startUp:{
			[state.Off]			state = State.ToIdle;
			[otherwise]			illegal;
		}		
		
		on startStop:
		{
			[state.Idle]		{}
			[state.Scan]		{}
			[state.Push]		{}
			[state.ToIdle]		{}
			[state.MoveWhite]	{}
			[state.MoveBlack]	{}
			[state.Aborted]		{state = State.ToIdle;}
			[otherwise]			illegal;
		}
		on abort:
		{
			[state.Off]			illegal;
			[state.Aborted]		{}
			[otherwise]			{state = State.Aborted;}
		}	
		
	}
	
}

interface SensorIF
{
	in void enable();
	in void disable();
	
	out void triggered();
	
	behaviour
	{
		enum State { Disabled, Enabled, Triggered };
		State state = State.Disabled;
		
		[state.Disabled]
		{
			on enable:			state = State.Enabled;
			on disable:			{}
		}
		[state.Enabled]
		{
			on enable:			illegal;
			on disable:			state = State.Disabled;
			on optional:		{triggered; state = State.Triggered;}
		}
		[state.Triggered]
		{
			on enable:			illegal;
			on disable:			state = State.Disabled;
		}
	}
}

interface ColourDetIF
{
	in void enable();
	in void disable();
	
	out void white();
	out void black();
	
	behaviour
	{
		enum State { Disabled, Enabled, Triggered };
		State state = State.Disabled;
		
		[state.Disabled]
		{
			on enable:			state = State.Enabled;
			on disable:			{}
		}
		[state.Enabled]
		{
			on enable:			illegal;
			on disable:			state = State.Disabled;
			on optional:		{black;state = State.Triggered;}
			on optional:		{white;state = State.Triggered;}
		}
		[state.Triggered]
		{
			on enable:			illegal;
			on disable:			{state = State.Disabled;}
		}
	}
}

interface MotorIF
{
	in void turnCW();
	in void turnCCW();
	in void disable();
	
	out void turningCW();
	out void turningCCW();
	out void disabled();
	
	behaviour
	{
		enum State { Disabled, TurnCW, TurnCCW, Disabling};
		State state = State.Disabled;
		
		on turnCW:
		{
			[state.Disabled]	{turningCW;state = State.TurnCW;}
			[otherwise]			{illegal;}
		}
		on turnCCW:
		{
			[state.Disabled]	{turningCCW;state = State.TurnCCW;}
			[otherwise]			{illegal;}
		}
		on disable:
		{
			[state.TurnCW]		{disabled;state = State.Disabled;}
			[state.TurnCCW]		{disabled;state = State.Disabled;}
			[otherwise]			{}
		}
	}
}

interface ButtonIF {
	
	in void pressed();
	in void notPressed();
	
	out void pressing();
	out void notPressing();
	
	behaviour {
				
		enum State {Pressed, NotPressed};
		State state = State.NotPressed;
		
		on pressed:
		{
			[State.NotPressed]	{pressing;state = State.Pressed;}
			[State.Pressed]		{}
			[otherwise]			{illegal;}
		}
		
		on notPressed:
		{
			[State.Pressed]		{notPressing; state = State.NotPressed;}
			[otherwise]			{}
		}
	}	
}

component BucketSort
{
	provides PP2IF pp2;
	requires SensorIF sensor1;
	requires SensorIF sensor2;
	requires ColourDetIF colourDet1;
	requires ColourDetIF colourDet2;
	requires MotorIF motorPush;
	requires MotorIF motorConveyor;
	requires MotorIF motorBucket;
	requires ButtonIF buttonPush;
	requires ButtonIF buttonBucket;
	
	behaviour {
		
		
	}
	
	
}
